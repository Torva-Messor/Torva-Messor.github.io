<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Torva Viewer - QR All Blue - iOS Sync Fix</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css">

    <style>
        :root { 
            --neon-blue: #00f2ff; 
            --neon-purple: #bc13fe; 
            --matrix-green: #00ff41; 
            --damage-red: #ff0055; 
            --bg-deep: #050505; 
            --qr-dark: #111;
        }
        body { background: var(--bg-deep); overflow: hidden; font-family: 'Courier New', monospace; margin: 0; }
        
        /* Der Hintergrund mit dem Grid */
        #background-layer { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            display: flex; justify-content: center; align-items: center; 
            z-index: 1; perspective: 1200px; 
            transition: opacity 0.8s ease; 
        }

        .morph-grid {
            display: grid;
            grid-template-columns: repeat(21, 1fr);
            grid-template-rows: repeat(21, 1fr);
            gap: 2px; 
            width: 80vmin; height: 80vmin;
            transition: transform 1s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform-style: preserve-3d;
        }

        .cell { 
            width: 100%; height: 100%; 
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1); 
            position: relative; border-radius: 2px; 
            opacity: 0.1; 
            background: #333;
        }

        /* MODES */
        .mode-go .cell { border-radius: 50%; opacity: 1; transform: scale(0.85); }
        .mode-go .cell.black { background: #111; box-shadow: inset 2px 2px 5px rgba(255,255,255,0.1); }
        .mode-go .cell.white { background: #eee; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .mode-go .cell.empty { opacity: 0.05; background: #fff; }

        .mode-qr .cell { transform: scale(1); border-radius: 0; opacity: 1; }
        .mode-qr .cell.finder-outer { background: var(--neon-blue); box-shadow: 0 0 8px rgba(0, 242, 255, 0.6); }
        .mode-qr .cell.finder-inner { background: var(--qr-dark); } 
        .mode-qr .cell.finder-center { background: var(--neon-blue); box-shadow: 0 0 12px rgba(0, 242, 255, 0.9); }
        
        .mode-qr .cell.is-sync.bit-1 { background: var(--neon-blue); box-shadow: 0 0 4px rgba(0, 242, 255, 0.4); }
        .mode-qr .cell.is-sync.bit-0 { background: var(--qr-dark); }
        .mode-qr .cell.is-version.bit-1 { background: var(--neon-blue); box-shadow: 0 0 4px rgba(0, 242, 255, 0.4); }
        .mode-qr .cell.is-version.bit-0 { background: var(--qr-dark); }
        .mode-qr .cell.is-data.bit-1 { background: var(--neon-blue); box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); }
        .mode-qr .cell.is-data.bit-0 { background: var(--qr-dark); }

        /* Highlight Modes */
        .highlight-finders .cell:not(.finder-outer):not(.finder-inner):not(.finder-center) { opacity: 0.05; transform: scale(0.5); }
        .highlight-finders .cell.finder-outer, .highlight-finders .cell.finder-center { transform: scale(1.1); z-index: 10; }

        .highlight-sync .cell:not(.is-sync) { opacity: 0.05; transform: scale(0.5); }
        .highlight-sync .cell.is-sync { opacity: 1; background: var(--matrix-green) !important; box-shadow: 0 0 15px var(--matrix-green) !important; transform: scale(1.2); z-index: 10; border-radius: 50%; }

        .highlight-version .cell:not(.is-version) { opacity: 0.05; transform: scale(0.5); }
        .highlight-version .cell.is-version.bit-1 { opacity: 1; background: var(--neon-purple) !important; box-shadow: 0 0 15px var(--neon-purple) !important; transform: scale(0.9); z-index: 10; }

        .cell.damaged { background: var(--damage-red) !important; box-shadow: 0 0 15px var(--damage-red) !important; opacity: 1 !important; z-index: 20; }
        
        /* Video Container */
        #video-container { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; 
            background: black; opacity: 0; pointer-events: none; 
            transition: opacity 0.5s; display: flex; justify-content: center; align-items: center; 
        }
        #video-container.active { opacity: 1; pointer-events: all; }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* --- AR Anpassungen: Fullscreen & Clean --- */
        #ar-viewer-container { 
            width: 100vw; height: 100dvh; 
            background: #000; 
            margin: 0; padding: 0;
            position: absolute; top: 0; left: 0;
        }
        model-viewer { width: 100%; height: 100%; }

        .ar-button {
            background-color: var(--neon-blue);
            border-radius: 4px; border: none;
            position: absolute; bottom: 60px; right: 30px;
            padding: 15px 30px;
            font-family: 'Courier New', monospace; font-weight: bold; font-size: 18px;
            color: #000; box-shadow: 0 0 20px rgba(0, 242, 255, 0.7);
            cursor: pointer; z-index: 1000;
        }
        
        #btn-start { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            border: 2px solid var(--neon-blue); color: var(--neon-blue); 
            background: rgba(0,0,0,0.9); padding: 20px 40px; font-size: 1.5rem; 
            cursor: pointer; z-index: 100; font-family: sans-serif; 
            text-transform: uppercase; letter-spacing: 3px; 
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
        }
        
        #sync-debug {
            position: fixed; bottom: 10px; right: 10px; color: #0f0; font-size: 12px; font-family: monospace; z-index: 200; pointer-events: none; background: rgba(0,0,0,0.7); padding: 5px;
        }
    </style>
</head>
<body>
    <button id="btn-start" onclick="initSystem()">INITIALIZE SYSTEM</button>
    <div id="sync-debug">System Offline</div>
    
    <div id="video-container">
        <video id="main-video" playsinline webkit-playsinline preload="auto">
            <source src="qr-code-pubnub-torva-project.mp4" type="video/mp4">
        </video>
    </div>
    
    <div id="background-layer"><div id="grid" class="morph-grid mode-go"></div></div>

    <div class="reveal"><div class="slides">
        <section data-state="state-go"></section>
        <section data-state="state-qr"></section>
        
        <section data-state="state-ar" style="padding: 0; margin: 0;">
            <div id="ar-viewer-container">
                <model-viewer 
                    src="https://modelviewer.dev/shared-assets/models/Astronaut.glb" 
                    ar 
                    ar-modes="webxr scene-viewer quick-look" 
                    camera-controls 
                    auto-rotate 
                    shadow-intensity="1">
                    
                    <button slot="ar-button" class="ar-button">
                        AR KAMERA STARTEN
                    </button>
                </model-viewer>
            </div>
        </section>
    </div></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
    <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.7.6.3.min.js"></script>
    
    <script>
        // --- Setup Reveal.js ---
        const deck = new Reveal();
        deck.initialize({ 
            controls: false, 
            progress: false, 
            hash: false, 
            transition: 'fade',
            width: "100%",    
            height: "100%",   
            margin: 0,        
            minScale: 1,
            maxScale: 1 
        });
        
        // --- Variablen ---
        const grid = document.getElementById('grid');
        const bgLayer = document.getElementById('background-layer');
        const cells = [];
        const gridSize = 21; 
        const debugEl = document.getElementById('sync-debug');
        const video = document.getElementById('main-video');
        const container = document.getElementById('video-container');

        // Sync State
        let globalVideoState = {
            startTime: 0,
            isPlaying: false
        };
        let timeOffset = 0;
        let lastSyncUpdate = 0; // Für Throttling

        // --- AR Anzeige-Logik ---
        deck.on('slidechanged', event => {
            const currentState = event.currentSlide.getAttribute('data-state');
            if (currentState === 'state-ar') {
                bgLayer.style.opacity = '0'; // Hintergrund aus
            } else {
                bgLayer.style.opacity = '1'; // Hintergrund an
            }
        });

        // --- Grid Initialisierung ---
        for(let i=0; i<gridSize*gridSize; i++) {
            let div = document.createElement('div');
            div.className = 'cell';
            grid.appendChild(div);
            cells.push(div);
        }

        // --- Grid Helper Funktionen ---
        function clearClasses() {
            grid.classList.remove('mode-go', 'mode-qr', 'highlight-finders', 'highlight-sync', 'highlight-version');
            cells.forEach(c => c.className = 'cell');
        }

        function renderGo() {
            clearClasses();
            grid.classList.add('mode-go');
            cells.forEach(c => {
                let r = Math.random();
                if(r > 0.8) c.classList.add('black');
                else if(r > 0.6) c.classList.add('white');
                else c.classList.add('empty');
            });
        }

        function identifyCellType(x, y) {
            const isTopLeft = x <= 6 && y <= 6;
            const isTopRight = x >= 14 && y <= 6;
            const isBottomLeft = x <= 6 && y >= 14;

            if (isTopLeft || isTopRight || isBottomLeft) {
                let localX = isTopRight ? x - 14 : x;
                let localY = isBottomLeft ? y - 14 : y;
                if (localX === 0 || localX === 6 || localY === 0 || localY === 6) return 'finder-outer';
                if (localX === 1 || localX === 5 || localY === 1 || localY === 5) return 'finder-inner';
                return 'finder-center';
            }
            if ((x === 6 && y >= 7 && y <= 13) || (y === 6 && x >= 7 && x <= 13)) return 'is-sync';
            if ((x <= 8 && y === 8) || (x === 8 && y <= 8) || (x >= 13 && y === 8) || (x === 8 && y >= 13)) return 'is-version';
            return 'is-data';
        }

        function renderQRStructure(highlightMode = null) {
            grid.classList.remove('highlight-finders', 'highlight-sync', 'highlight-version');
            if(!grid.classList.contains('mode-qr')) {
                clearClasses();
                grid.classList.add('mode-qr');
                cells.forEach((c, i) => {
                    const x = i % gridSize; 
                    const y = Math.floor(i / gridSize);
                    const type = identifyCellType(x, y);
                    c.classList.add(type);
                    if (type === 'is-data' || type === 'is-version') {
                        c.classList.add(Math.random() > 0.5 ? 'bit-1' : 'bit-0');
                    } else if (type === 'is-sync') {
                        let isEven = (x === 6 ? y : x) % 2 === 0;
                        c.classList.add(isEven ? 'bit-1' : 'bit-0');
                    }
                });
            }
            if(highlightMode) grid.classList.add(highlightMode);
        }

        // --- OPTIMIERTE SYNC LOGIK ---
        function syncLoop() {
            if (!globalVideoState.isPlaying) return;

            requestAnimationFrame(syncLoop);

            // 1. Throttling: Nur alle 250ms Logik ausführen
            // Das verhindert das "Stottern" auf iOS
            const now = Date.now();
            if (now - lastSyncUpdate < 250) return;
            lastSyncUpdate = now;

            const nowServer = now + timeOffset;
            const expectedTime = (nowServer - globalVideoState.startTime) / 1000;
            const drift = expectedTime - video.currentTime;
            
            debugEl.innerText = `D: ${(drift*1000).toFixed(0)}ms | Rate: ${video.playbackRate.toFixed(2)}`;

            // 2. Hard Sync (Seek) nur bei groben Fehlern (> 2 Sekunden)
            if (Math.abs(drift) > 2.0) {
                console.log("Hard Sync trigger");
                video.currentTime = expectedTime;
                video.playbackRate = 1.0;
                return;
            }

            // 3. Soft Sync mit Deadband (Toleranzbereich)
            // Wenn Drift < 80ms ist, nichts tun (Video läuft "gut genug")
            if (Math.abs(drift) < 0.08) {
                if (video.playbackRate !== 1.0) video.playbackRate = 1.0;
            }
            else {
                // Sanfte Anpassung
                // Wir begrenzen die Rate zwischen 0.95x und 1.05x, damit Audio nicht leiert
                let targetRate = 1.0;
                
                if (drift > 0) {
                    // Wir sind zu langsam -> schneller
                    targetRate = 1.0 + Math.min(drift, 0.08); // Max 1.08x
                } else {
                    // Wir sind zu schnell -> langsamer
                    targetRate = 1.0 + Math.max(drift, -0.08); // Min 0.92x
                }
                
                // Nur zuweisen, wenn Unterschied signifikant, um Browser-API-Calls zu sparen
                if (Math.abs(video.playbackRate - targetRate) > 0.01) {
                    video.playbackRate = targetRate;
                }
            }
        }

        // --- ROBUSTE ZEIT KALIBRIERUNG (Median-Methode) ---
        async function calibrateTime(pubnub) {
            debugEl.innerText = "Calibrating Time...";
            let offsets = [];
            
            // Wir nehmen 5 Messwerte und nehmen den Median
            for(let i=0; i<5; i++) {
                await new Promise(resolve => {
                    const start = Date.now();
                    pubnub.time((status, response) => {
                        if (!status.error) {
                            const end = Date.now();
                            const latency = (end - start) / 2;
                            // PubNub Token (17 digits) -> ms (13 digits) = /10000
                            const serverTime = response.timetoken / 10000;
                            const offset = serverTime - end + latency;
                            offsets.push(offset);
                        }
                        resolve();
                    });
                });
                // Kurze Pause zwischen Pings
                await new Promise(r => setTimeout(r, 50));
            }
            
            // Sortieren und Median wählen
            offsets.sort((a,b) => a-b);
            timeOffset = offsets[Math.floor(offsets.length/2)];
            console.log("Calibrated Offset (Median):", timeOffset);
            debugEl.innerText = "System Ready";
        }

        // --- Hauptinitialisierung ---
        function initSystem() {
            document.getElementById('btn-start').style.display = 'none';
            
            // iOS Audio Unlock Hack
            video.muted = false;
            video.play().then(() => {
                video.pause();
                video.currentTime = 0;
            }).catch(e => {
                console.warn("Autoplay restriction", e);
                video.muted = true; // Fallback
                video.play().then(() => video.pause());
            });

            const pubnub = new PubNub({ 
                subscribeKey: 'sub-c-6fdfc9e3-91b8-4f79-b62a-6fd9fc69eff7', 
                userId: "v15-viewer-" + Math.floor(Math.random()*10000) 
            });
            
            // Start Calibration
            calibrateTime(pubnub);

            // PubNub Listener
            pubnub.addListener({
                message: (m) => {
                    const msg = m.message;
                    if(msg.slide !== undefined) deck.slide(msg.slide);
                    
                    if(msg.action === 'morph_go') renderGo();
                    if(msg.action === 'morph_qr') renderQRStructure(); 
                    if(msg.action === 'highlight_finders') renderQRStructure('highlight-finders');
                    if(msg.action === 'highlight_sync') renderQRStructure('highlight-sync');
                    if(msg.action === 'highlight_version') renderQRStructure('highlight-version');
                    
                    if(msg.action === 'damage') {
                        let dataCells = cells.filter(c => c.classList.contains('is-data') && c.classList.contains('bit-1'));
                        for(let i=0; i<15; i++) if(dataCells.length > 0) dataCells[Math.floor(Math.random()*dataCells.length)].classList.add('damaged');
                    }
                    if(msg.action === 'heal') {
                        cells.forEach(c => c.classList.remove('damaged'));
                        renderQRStructure();
                    }
                    
                    // Video Sync Empfang
                    if (msg.action === 'video_sync') {
                        if (msg.videoState === 'play') {
                            globalVideoState.startTime = msg.startTime;
                            globalVideoState.isPlaying = true;
                            
                            container.classList.add('active');
                            
                            if (video.paused) {
                                const nowServer = Date.now() + timeOffset;
                                const targetPos = (nowServer - globalVideoState.startTime) / 1000;
                                
                                // Initial Seek wenn nötig
                                if (targetPos > 0) video.currentTime = targetPos;
                                
                                video.play().catch(() => {
                                    video.muted = true;
                                    video.play();
                                });
                            }
                            // Starte Sync Loop
                            requestAnimationFrame(syncLoop);
                            
                        } else {
                            globalVideoState.isPlaying = false;
                            container.classList.remove('active');
                            video.pause();
                            video.currentTime = 0;
                            video.playbackRate = 1.0;
                        }
                    }
                }
            });
            
            pubnub.subscribe({ channels: ['PrasiW.Woche'] });
            renderGo();
        }
    </script>
</body>
</html>
