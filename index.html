<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Torva Viewer - Smooth & AR Fixed</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css">

    <style>
        :root { 
            --neon-blue: #00f2ff; 
            --neon-purple: #bc13fe; 
            --matrix-green: #00ff41; 
            --damage-red: #ff0000; 
            --bg-deep: #050505; 
            --qr-dark: #000000; 
        }
        body { background: var(--bg-deep); overflow: hidden; font-family: 'Courier New', monospace; margin: 0; }
        
        #background-layer { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            display: flex; justify-content: center; align-items: center; 
            z-index: 1; perspective: 1000px;
        }

        /* Scanlines */
        body::after {
            content: "";
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px);
            pointer-events: none; z-index: 900;
            opacity: 1; transition: opacity 0.5s ease;
        }
        body.video-active::after { opacity: 0; }

        .morph-grid {
            display: grid;
            grid-template-columns: repeat(21, 1fr);
            grid-template-rows: repeat(21, 1fr);
            gap: 2px; 
            width: 80vmin; height: 80vmin;
            transition: transform 1.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform-style: preserve-3d;
        }

        .cell { 
            width: 100%; height: 100%; 
            /* Optimierte Transition für alle Eigenschaften */
            transition: background-color 0.8s, transform 0.8s cubic-bezier(0.4, 0.0, 0.2, 1), border-radius 0.6s, opacity 0.6s, box-shadow 0.6s;
            position: relative; 
            will-change: transform, background-color, border-radius;
        }

        /* =========================================
           MODE: GO (Aktiviert durch Parent Class)
           ========================================= */
        .mode-go .cell { 
            border-radius: 50%; 
            opacity: 1; 
            transform: scale(0.85); 
        }
        
        /* Go: Schwarzer Stein */
        .mode-go .cell.go-black { 
            background: radial-gradient(circle at 35% 35%, #444, #000);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.8);
            z-index: 2;
        }
        
        /* Go: Weißer Stein */
        .mode-go .cell.go-white { 
            background: radial-gradient(circle at 35% 35%, #fff, #bbb);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5); 
            z-index: 2;
        }
        
        /* Go: Leer */
        .mode-go .cell.go-empty { 
            opacity: 0.1; 
            transform: scale(0.2); 
            background: #333; 
            box-shadow: none;
        }

        /* =========================================
           MODE: QR (Aktiviert durch Parent Class)
           ========================================= */
        .mode-qr .cell { 
            transform: scale(1); 
            border-radius: 1px; 
            opacity: 1; 
            /* Reset Shadows from Go Mode */
            box-shadow: none; 
        }
        
        /* QR: Finder Patterns */
        .mode-qr .cell.qr-finder-outer { background: var(--neon-blue); box-shadow: 0 0 15px rgba(0, 242, 255, 0.5); z-index: 2; }
        .mode-qr .cell.qr-finder-inner { background: var(--qr-dark); } 
        .mode-qr .cell.qr-finder-center { background: var(--neon-blue); box-shadow: 0 0 20px rgba(0, 242, 255, 0.8); z-index: 2; }
        
        /* QR: Bits */
        .mode-qr .cell.qr-bit-1 { background: var(--neon-blue); box-shadow: 0 0 4px rgba(0, 242, 255, 0.2); }
        .mode-qr .cell.qr-bit-0 { background: var(--qr-dark); transform: scale(0.95); }

        /* --- HIGHLIGHT MODES (Overlays für QR) --- */
        /* Alles ausblenden was nicht Ziel ist */
        .highlight-finders .cell:not(.qr-finder-outer):not(.qr-finder-inner):not(.qr-finder-center),
        .highlight-sync .cell:not(.qr-is-sync),
        .highlight-version .cell:not(.qr-is-version) { 
            opacity: 0.1; transform: scale(0.8) blur(2px); filter: grayscale(100%);
        }

        /* Animationen */
        .highlight-finders .cell.qr-finder-outer { animation: pulse-blue 1.5s infinite; }
        .highlight-sync .cell.qr-is-sync.qr-bit-1 { background: var(--matrix-green) !important; box-shadow: 0 0 20px var(--matrix-green) !important; z-index: 10; animation: pulse-green 1s infinite; }
        .highlight-version .cell.qr-is-version.qr-bit-1 { background: var(--neon-purple) !important; box-shadow: 0 0 20px var(--neon-purple) !important; z-index: 10; animation: pulse-purple 1s infinite; }

        @keyframes pulse-blue { 0%, 100% { box-shadow: 0 0 10px var(--neon-blue); } 50% { box-shadow: 0 0 25px var(--neon-blue); transform: scale(1.05); } }
        @keyframes pulse-green { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.3); opacity: 1; box-shadow: 0 0 30px var(--matrix-green); } }
        @keyframes pulse-purple { 0%, 100% { transform: scale(0.9); } 50% { transform: scale(1.1); box-shadow: 0 0 30px var(--neon-purple); } }

        /* Damage Effect */
        .cell.damaged { 
            background: var(--damage-red) !important; 
            box-shadow: 0 0 15px var(--damage-red) !important; 
            opacity: 1 !important; z-index: 20; transform: scale(0.9) !important; 
        }

        /* --- AR VIEW UPDATE --- */
        #ar-viewer-container { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: #000; z-index: 60; opacity: 0; pointer-events: none;
            transition: opacity 1s ease-in-out;
        }
        
        .state-ar #ar-viewer-container { opacity: 1; pointer-events: all; }

        model-viewer { width: 100%; height: 100%; --poster-color: transparent; }

        /* AR Button - Fixed Visibility */
        #ar-button {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            border: 1px solid var(--neon-blue); color: var(--neon-blue); 
            background: rgba(0,10,20,0.9); padding: 15px 30px; font-size: 1rem; 
            cursor: pointer; font-family: 'Courier New', monospace; 
            text-transform: uppercase; letter-spacing: 2px; border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
            /* WICHTIG: Display Block, damit er da ist, wenn AR verfügbar */
            display: block; 
            white-space: nowrap;
        }
        #ar-button:hover { background: var(--neon-blue); color: #000; box-shadow: 0 0 40px var(--neon-blue); }

        /* Wenn AR nicht supported ist, versteckt Model-Viewer den Button automatisch.
           Wir können aber fallback erzwingen wenn nötig, aber standard ist sicherer. */

        /* Video / UI */
        #video-container { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; 
            background: black; opacity: 0; pointer-events: none; 
            transition: opacity 0.8s ease-in-out; display: flex; justify-content: center; align-items: center; 
        }
        #video-container.active { opacity: 1; pointer-events: all; }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        #btn-start { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            border: 1px solid var(--neon-blue); color: var(--neon-blue); 
            background: rgba(0,10,20,0.95); padding: 20px 50px; font-size: 1.2rem; 
            cursor: pointer; z-index: 100; font-family: sans-serif; 
            text-transform: uppercase; letter-spacing: 4px; 
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.2);
            transition: all 0.3s;
        }
        #btn-start:hover { background: var(--neon-blue); color: #000; box-shadow: 0 0 50px var(--neon-blue); }
        
        #sync-debug {
            position: fixed; bottom: 10px; right: 10px; color: var(--matrix-green); font-size: 10px; font-family: monospace; z-index: 200; pointer-events: none; background: rgba(0,0,0,0.8); padding: 5px 10px; border-radius: 4px;
        }
    </style>
</head>
<body>
    <button id="btn-start" onclick="initSystem()">INITIALIZE SYSTEM</button>
    <div id="sync-debug">System Offline</div>
    
    <div id="video-container">
        <video id="main-video" playsinline webkit-playsinline preload="auto">
            <source src="qr-code-pubnub-torva-project.mp4" type="video/mp4">
        </video>
    </div>

    <div id="ar-viewer-container">
        <model-viewer 
            src="https://modelviewer.dev/shared-assets/models/Astronaut.glb" 
            ar 
            ar-modes="webxr scene-viewer quick-look" 
            camera-controls 
            auto-rotate 
            shadow-intensity="1">
            
            <button slot="ar-button" id="ar-button">
                ENTER AR REALITY
            </button>
        </model-viewer>
    </div>
    
    <div id="background-layer"><div id="grid" class="morph-grid mode-go"></div></div>

    <div class="reveal"><div class="slides">
        <section data-state="state-go"></section>
        <section data-state="state-qr"></section>
        <section data-state="state-ar"></section> </div></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
    <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.7.6.3.min.js"></script>
    <script>
        const deck = new Reveal();
        deck.initialize({ controls: false, progress: false, hash: false, transition: 'fade' });
        
        const grid = document.getElementById('grid');
        const cells = [];
        const gridSize = 21; 
        const debugEl = document.getElementById('sync-debug');

        let timeOffset = 0;
        let videoPlayer = document.getElementById('main-video');
        let videoContainer = document.getElementById('video-container');
        let globalVideoState = { startTime: 0, isPlaying: false, syncLoopActive: false };

        // --- PRE-CALCULATION & SETUP ---
        // Wir bauen das Grid nur EINMAL und weisen alle Klassen sofort zu.
        // Das verhindert Ruckeln beim Umschalten.
        
        for(let i=0; i<gridSize*gridSize; i++) {
            let div = document.createElement('div');
            div.className = 'cell';
            
            // 1. Assign GO Identity (Random)
            let r = Math.random();
            if(r > 0.8) div.classList.add('go-black'); 
            else if(r > 0.6) div.classList.add('go-white'); 
            else div.classList.add('go-empty');

            // 2. Assign QR Identity (Deterministic)
            const x = i % gridSize; 
            const y = Math.floor(i / gridSize);
            const qrType = identifyCellType(x, y); // Berechne Typ
            
            // Mapping für CSS Selektoren
            if(qrType === 'finder-outer') div.classList.add('qr-finder-outer');
            if(qrType === 'finder-inner') div.classList.add('qr-finder-inner');
            if(qrType === 'finder-center') div.classList.add('qr-finder-center');
            if(qrType === 'is-sync') div.classList.add('qr-is-sync');
            if(qrType === 'is-version') div.classList.add('qr-is-version');
            
            // Bits setzen
            if (qrType === 'is-data' || qrType === 'is-version') {
                div.classList.add(Math.random() > 0.5 ? 'qr-bit-1' : 'qr-bit-0');
            } else if (qrType === 'is-sync') {
                let isEven = (x === 6 ? y : x) % 2 === 0;
                div.classList.add(isEven ? 'qr-bit-1' : 'qr-bit-0');
            } else {
                // Finder patterns sind immer "an"
                div.classList.add('qr-bit-1');
            }

            grid.appendChild(div);
            cells.push(div);
        }

        // --- LOGIC FUNCTIONS ---

        function randomizeDelays(intensity = 100) {
            cells.forEach(c => {
                const delay = Math.floor(Math.random() * intensity);
                c.style.transitionDelay = `${delay}ms`;
            });
        }

        function identifyCellType(x, y) {
            const isTopLeft = x <= 6 && y <= 6;
            const isTopRight = x >= 14 && y <= 6;
            const isBottomLeft = x <= 6 && y >= 14;

            if (isTopLeft || isTopRight || isBottomLeft) {
                let localX = isTopRight ? x - 14 : x;
                let localY = isBottomLeft ? y - 14 : y;
                if (localX === 0 || localX === 6 || localY === 0 || localY === 6) return 'finder-outer';
                if (localX === 1 || localX === 5 || localY === 1 || localY === 5) return 'finder-inner';
                return 'finder-center';
            }
            if ((x === 6 && y >= 7 && y <= 13) || (y === 6 && x >= 7 && x <= 13)) return 'is-sync';
            if ((x <= 8 && y === 8) || (x === 8 && y <= 8) || (x >= 13 && y === 8) || (x === 8 && y >= 13)) return 'is-version';
            return 'is-data';
        }

        // --- RENDER MODES (Pure CSS Switching) ---

        function renderGo() {
            randomizeDelays(400); 
            // Wir tauschen nur die Parent-Class. 
            // Der Browser interpoliert die Eigenschaften (kein JS Loop nötig).
            grid.classList.remove('mode-qr', 'highlight-finders', 'highlight-sync', 'highlight-version');
            grid.classList.add('mode-go');
        }

        function renderQRStructure(highlightMode = null) {
            randomizeDelays(150);
            
            // Erst in den Basis-QR Modus wechseln
            grid.classList.remove('mode-go', 'highlight-finders', 'highlight-sync', 'highlight-version');
            grid.classList.add('mode-qr');

            // Optional Highlights adden
            if(highlightMode) {
                // Bei Highlights Delay entfernen für direkteres Feedback
                cells.forEach(c => c.style.transitionDelay = '0ms');
                grid.classList.add(highlightMode);
            }
        }

        // --- SYNC & PUBNUB (Unverändert gut) ---
        async function syncServerTime(pubnubInstance) {
            const start = Date.now();
            return new Promise((resolve) => {
                pubnubInstance.time((status, response) => {
                    if (!status.error) {
                        const end = Date.now();
                        const latency = (end - start) / 2;
                        timeOffset = (response.timetoken / 10000) - Date.now() + latency;
                        debugEl.innerText = `Offset: ${Math.round(timeOffset)}ms`;
                        resolve();
                    }
                });
            });
        }

        function syncLoop() {
            if (!globalVideoState.isPlaying) return;
            const nowServer = Date.now() + timeOffset;
            const expectedTime = (nowServer - globalVideoState.startTime) / 1000;
            const drift = expectedTime - videoPlayer.currentTime;

            if (Math.abs(drift) < 0.04) {
                if (videoPlayer.playbackRate !== 1.0) videoPlayer.playbackRate = 1.0;
            } else if (Math.abs(drift) <= 1.0) {
                let newRate = 1.0 + (drift * 0.15);
                newRate = Math.min(Math.max(newRate, 0.95), 1.05);
                videoPlayer.playbackRate = newRate;
            } else {
                videoPlayer.currentTime = expectedTime;
                videoPlayer.playbackRate = 1.0;
            }
            requestAnimationFrame(syncLoop);
        }

        function initSystem() {
            const btn = document.getElementById('btn-start');
            btn.style.opacity = '0';
            setTimeout(() => btn.style.display = 'none', 500);

            videoPlayer.muted = false;
            videoPlayer.play().then(() => {
                videoPlayer.pause();
                videoPlayer.currentTime = 0;
            }).catch(() => { videoPlayer.muted = true; });

            const pubnub = new PubNub({ subscribeKey: 'sub-c-6fdfc9e3-91b8-4f79-b62a-6fd9fc69eff7', userId: "v15-" + Math.floor(Math.random()*10000) });
            syncServerTime(pubnub);

            pubnub.addListener({
                message: (m) => {
                    const msg = m.message;
                    if(msg.slide !== undefined) deck.slide(msg.slide);
                    
                    // State Handling via CSS Classes
                    if(msg.action === 'morph_go') renderGo();
                    if(msg.action === 'morph_qr') renderQRStructure(); 
                    if(msg.action === 'highlight_finders') renderQRStructure('highlight-finders');
                    if(msg.action === 'highlight_sync') renderQRStructure('highlight-sync');
                    if(msg.action === 'highlight_version') renderQRStructure('highlight-version');
                    
                    if(msg.action === 'damage') {
                        let dataCells = cells.filter(c => c.classList.contains('qr-bit-1'));
                        for(let i=0; i<20; i++) if(dataCells.length) dataCells[Math.floor(Math.random()*dataCells.length)].classList.add('damaged');
                    }
                    if(msg.action === 'heal') {
                        cells.forEach(c => c.classList.remove('damaged'));
                    }
                    
                    // Video Sync logic
                    if(msg.action === 'video_sync') {
                        if(msg.videoState === 'play') {
                            globalVideoState.startTime = msg.startTime;
                            globalVideoState.isPlaying = true;
                            videoContainer.classList.add('active');
                            document.body.classList.add('video-active');
                            if (videoPlayer.paused) videoPlayer.play();
                            if (!globalVideoState.syncLoopActive) {
                                globalVideoState.syncLoopActive = true;
                                requestAnimationFrame(syncLoop);
                            }
                        } else {
                            globalVideoState.isPlaying = false;
                            videoContainer.classList.remove('active');
                            document.body.classList.remove('video-active');
                            videoPlayer.pause();
                        }
                    }
                }
            });
            pubnub.subscribe({ channels: ['PrasiW.Woche'] });
            
            // Start State
            renderGo();
        }
        
        // Listener for Reveal.js state changes (Fallback)
        deck.on('slidechanged', event => {
            if(event.currentSlide.dataset.state === 'state-ar') {
                document.getElementById('ar-viewer-container').classList.add('state-ar');
            } else {
                document.getElementById('ar-viewer-container').classList.remove('state-ar');
            }
        });

    </script>
</body>
</html>
